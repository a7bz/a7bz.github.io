import{_ as i,p as a,R as s,k as l}from"./chunks/framework.D4eJsr-_.js";const t=JSON.parse('{"title":"博客上次修改时间的正确实现","description":"","frontmatter":{"icon":"blog","date":"2026-01-17T00:00:00.000Z","category":["问题解决"],"tag":["blog"]},"headers":[],"relativePath":"posts/2026/0117.md","filePath":"posts/2026/other/blogMtime-0117.md"}');const e=i({name:"posts/2026/0117.md"},[["render",function(i,t,e,n,o,r){return l(),a("div",null,[...t[0]||(t[0]=[s('<h1 id="博客上次修改时间的正确实现" tabindex="-1">博客上次修改时间的正确实现 <a class="header-anchor" href="#博客上次修改时间的正确实现" aria-label="Permalink to &quot;博客上次修改时间的正确实现&quot;">​</a></h1><h2 id="问题背景" tabindex="-1">问题背景 <a class="header-anchor" href="#问题背景" aria-label="Permalink to &quot;问题背景&quot;">​</a></h2><p>在博客搭建过程中，我发现一个困扰已久的问题：文章的&quot;上次修改时间&quot;总是显示为构建部署的时间，而不是文章内容真正的最后修改时间。这导致了以下问题：</p><ol><li><strong>信息不准确</strong>：读者无法了解文章的实际更新时间</li><li><strong>SEO 影响</strong>：搜索引擎可能会认为内容是最新的，影响搜索结果排序</li><li><strong>用户体验</strong>：定期构建部署会让所有文章的修改时间都被更新，造成混淆</li></ol><h2 id="原因分析" tabindex="-1">原因分析 <a class="header-anchor" href="#原因分析" aria-label="Permalink to &quot;原因分析&quot;">​</a></h2><p>经过排查，我发现问题出在 GitHub Actions 的工作流设计上：</p><ul><li>每次构建部署时，CI/CD 环境会重新克隆仓库</li><li>克隆后的文件会获得新的修改时间戳（即构建时间）</li><li>本博客默认使用文件系统的修改时间</li><li>因此所有文章的修改时间都被重置为构建时间</li></ul><h2 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h2><p>为了解决这个问题，我修改了 GitHub Actions 工作流文件，添加了文件修改时间恢复步骤：</p><h3 id="关键修改" tabindex="-1">关键修改 <a class="header-anchor" href="#关键修改" aria-label="Permalink to &quot;关键修改&quot;">​</a></h3><p>在 <code>.github/workflows/deploy-docs.yml</code> 文件中，我添加了以下步骤：</p><div class="language-yaml vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">恢复文件修改时间</span></span>\n<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  uses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">chetan/git-restore-mtime-action@v2</span></span>\n<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>\n<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">posts/</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="完整工作流分析" tabindex="-1">完整工作流分析 <a class="header-anchor" href="#完整工作流分析" aria-label="Permalink to &quot;完整工作流分析&quot;">​</a></h3><p>现在的完整工作流包含以下关键步骤：</p><ol><li><strong>代码检出</strong>：使用 <code>fetch-depth: 0</code> 获取完整历史记录，这对恢复时间戳至关重要</li><li><strong>环境设置</strong>：配置 Node.js 环境和依赖</li><li><strong>时间戳恢复</strong>：使用 <code>git-restore-mtime-action</code> 恢复 <code>posts/</code> 目录中文件的修改时间</li><li><strong>文档构建</strong>：正常构建文档</li><li><strong>部署</strong>：部署到 GitHub Pages</li></ol><h3 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h3><p><code>git-restore-mtime-action</code> 这个 GitHub Action 的工作原理是：</p><ol><li>分析 Git 仓库的提交历史</li><li>查找每个文件的最后一次提交时间</li><li>将文件系统的修改时间设置为该提交时间</li><li>这样就确保了文件的修改时间反映的是内容的实际更新时间，而非构建时间</li></ol><h2 id="实现效果" tabindex="-1">实现效果 <a class="header-anchor" href="#实现效果" aria-label="Permalink to &quot;实现效果&quot;">​</a></h2><p>通过这个修改，现在博客的&quot;上次修改时间&quot;显示的是：</p><ul><li><strong>准确的内容更新时间</strong>：反映文章真正的最后修改时间</li><li><strong>一致的时间戳</strong>：不受构建部署频率的影响</li><li><strong>更好的用户体验</strong>：读者可以清楚了解文章的更新状态</li><li><strong>更合理的 SEO</strong>：搜索引擎可以获得更准确的内容时效性信息</li></ul><h2 id="技术细节" tabindex="-1">技术细节 <a class="header-anchor" href="#技术细节" aria-label="Permalink to &quot;技术细节&quot;">​</a></h2><ol><li><p><strong>为什么使用 <code>fetch-depth: 0</code></strong>：</p><ul><li>这个参数确保克隆完整的 Git 历史记录</li><li>如果不设置，默认只会获取最近一次提交，无法恢复更早的文件修改时间</li></ul></li><li><p><strong>为什么只针对 <code>posts/</code> 目录</strong>：</p><ul><li>博客文章通常存储在 <code>posts/</code> 目录中</li><li>只恢复这个目录的时间戳可以提高构建效率</li><li>其他配置文件和模板文件的修改时间对读者意义不大</li></ul></li><li><p><strong>为什么选择 <code>chetan/git-restore-mtime-action</code></strong>：</p><ul><li>这是一个专门用于恢复 Git 文件修改时间的 Action</li><li>配置简单，使用方便</li><li>支持指定目录，灵活性高</li><li>社区活跃度高，维护良好</li></ul></li></ol><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>通过修改 GitHub Actions 工作流，添加文件修改时间恢复步骤，我成功解决了博客上次修改时间显示为构建时间的问题。现在，博客文章的修改时间能够准确反映内容的实际更新时间，提升了用户体验和 SEO 效果。</p><p>这个解决方案不仅适用于我的博客，也可以推广到其他使用静态站点生成器的项目中，帮助更多开发者解决类似的时间戳问题。</p><p>如果你也遇到了类似的问题，不妨尝试在你的工作流中添加这个时间戳恢复步骤，让你的网站显示更准确的内容更新时间。</p>',27)])])}]]);export{t as __pageData,e as default};
